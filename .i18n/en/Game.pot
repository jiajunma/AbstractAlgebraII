msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Thu Apr  3 10:33:59 2025\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! 🎉"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings… 🎭"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! 🎉"
msgstr ""

#: Game.Levels.BasicLean.L01_rfl
msgid "Rfl tactic"
msgstr ""

#: Game.Levels.BasicLean.L01_rfl
msgid "This level gets you familiar with the game interface."
msgstr ""

#: Game.Levels.BasicLean.L01_rfl
msgid "The equality can be settaled by evaluation."
msgstr ""

#: Game.Levels.BasicLean.L01_rfl
msgid "You can use either `rfl` or `norm_num`."
msgstr ""

#: Game.Levels.BasicLean.L01_rfl
msgid "rfl and norm_num are very handy to close obvious goals."
msgstr ""

#: Game.Levels.BasicLean.L02_rw
msgid "Rewrite"
msgstr ""

#: Game.Levels.BasicLean.L02_rw
msgid "This level gets you familiar with the game interface."
msgstr ""

#: Game.Levels.BasicLean.L02_rw
msgid "You can use rw [h] to rewrite `x` by `2`."
msgstr ""

#: Game.Levels.BasicLean.L02_rw
msgid "You can either start using `«{h}»` or `«{g}»`."
msgstr ""

#: Game.Levels.BasicLean.L02_rw
msgid "You should use `«{h}»` now."
msgstr ""

#: Game.Levels.BasicLean.L02_rw
msgid "You should use `«{g}»` now."
msgstr ""

#: Game.Levels.BasicLean.L02_rw
msgid "rw is the most basic command you can use."
msgstr ""

#: Game.Levels.BasicLean
msgid "Basic Lean"
msgstr ""

#: Game.Levels.BasicLean
msgid "We start with some basic Lean tactics."
msgstr ""

#: Game.Levels.BasicGroupTheory.L01_identity
msgid "Suppose $G$ is a set with a binary operation $*$.\n"
"\n"
"The following statement claims that identity element is unique.\n"
"\n"
"Suppose $e$ and $e'$ are two identity elements, we need to prove $e=e'$."
msgstr ""

#: Game.Levels.BasicGroupTheory.L01_identity
msgid "Use `h1`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L01_identity
msgid "Use `h4`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L02_assoc
msgid "A semi-group is a set $G$ with a binary operation $*$ such that $*$ has associative law."
msgstr ""

#: Game.Levels.BasicGroupTheory.L02_assoc
msgid "Use `group`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L03_inverse
msgid "A  monoid is a semi-group with identity and .\n"
"\n"
"A  group is a monoid such that every element has inverse."
msgstr ""

#: Game.Levels.BasicGroupTheory.L03_inverse
msgid "Use `a⁻¹`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L03_inverse
msgid "Also can use And.intro to split the goal"
msgstr ""

#: Game.Levels.BasicGroupTheory.L03_inverse
msgid "Use `group`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L03_inverse
msgid "Use `group`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L04_inverse_unique
msgid "Note that if inverse exits, then it is unique."
msgstr ""

#: Game.Levels.BasicGroupTheory.L04_inverse_unique
msgid "Use `mul_one`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L04_inverse_unique
msgid "Use `leftinvc`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L04_inverse_unique
msgid "Use `assoc`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L04_inverse_unique
msgid "Use `rightinvb`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L04_inverse_unique
msgid "Use `one_mul`"
msgstr ""

#: Game.Levels.BasicGroupTheory.L05_Subgroup_def
msgid "A subgroup of a group $G$ is a nonempty subset $H$ of $G$ such that $*$ is closed under $H$ and inverse.\n"
"\n"
"We have a criterion for a set H to be a subgroup of $G$:\n"
"If H is non-empty and a ∈  H ∧ b ∈  H implies a * b⁻¹ ∈ H\n"
"then H is a subgroup of G\n"
"\n"
"The follow theorem show that,"
msgstr ""

#: Game.Levels.BasicGroupTheory.L06_kZ
msgid "For example, ℤ is a group under addition.\n"
"Now the set of even integers, 2ℤ := {2n | n ∈ ℤ }, is a subgroup of ℤ.\n"
"More generally, kℤ := {k*n | n ∈ ℤ } is also a subgroup of ℤ.\n"
"Morover, all subgoup of ℤ is of the form kℤ for some k ∈ ℕ.\n"
"\n"
"In fact, ℕ → {subgroup of ℤ} given by k ↦ kℤ is a bijection."
msgstr ""

#: Game.Levels.BasicGroupTheory.L06_kZ
msgid "Intro all elements"
msgstr ""

#: Game.Levels.BasicGroupTheory.L06_kZ
msgid "Use Int.sub_emod"
msgstr ""

#: Game.Levels.BasicGroupTheory.L06_kZ
msgid "Use hypothesis to simp the goal"
msgstr ""

#: Game.Levels.BasicGroupTheory.L07_Zn
msgid "Let Z_n be the set of integers modulo $n$.\n"
"Then Z_n form a commutative group (i.e. an Abelian group)."
msgstr ""

#: Game.Levels.BasicGroupTheory.L07_Zn
msgid "Use the definition to simplify the goal.\n"
"You can use `simp [add]'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L07_Zn
msgid "Use `ext' tactic"
msgstr ""

#: Game.Levels.BasicGroupTheory.L07_Zn
msgid "Use `simp' to simplify the goal"
msgstr ""

#: Game.Levels.BasicGroupTheory.L07_Zn
msgid "Use `add_assoc'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L07_Zn
msgid "Use the definition of neg"
msgstr ""

#: Game.Levels.BasicGroupTheory.L07_Zn
msgid "Use `add_comm'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L08_Commutator
msgid "A `⁅a,b⁆:=a * b * a⁻¹ * b⁻¹' is called the commutator of $a$ and $b$.\n"
"\n"
"A group is abelian if all commutators are one."
msgstr ""

#: Game.Levels.BasicGroupTheory.L08_Commutator
msgid "Use `constructor' to split the goal into two parts"
msgstr ""

#: Game.Levels.BasicGroupTheory.L08_Commutator
msgid "replace `a * b'  by `b * a' using the hypothesis"
msgstr ""

#: Game.Levels.BasicGroupTheory.L08_Commutator
msgid "Use `group' to finish the proof"
msgstr ""

#: Game.Levels.BasicGroupTheory.L08_Commutator
msgid "apply `mul_right_cancel' twice to translate the goal"
msgstr ""

#: Game.Levels.BasicGroupTheory.L08_Commutator
msgid "Rewrite the left hand side using the hypothesis"
msgstr ""

#: Game.Levels.BasicGroupTheory.L08_Commutator
msgid "Use `group' to finish the proof"
msgstr ""

#: Game.Levels.BasicGroupTheory.L09_ElementaryTwoGroup
msgid "If $G$ is a group such that $a * a = 1$ for all $a in G$, then $G$ is abelian."
msgstr ""

#: Game.Levels.BasicGroupTheory.L09_ElementaryTwoGroup
msgid "Use `mul_right_cancel' to translate the goal"
msgstr ""

#: Game.Levels.BasicGroupTheory.L09_ElementaryTwoGroup
msgid "Use the hypothesis"
msgstr ""

#: Game.Levels.BasicGroupTheory.L09_ElementaryTwoGroup
msgid "Use `group' to finish the proof"
msgstr ""

#: Game.Levels.BasicGroupTheory.L09_ElementaryTwoGroup
msgid "Use «{inv_eq_self}» smartly"
msgstr ""

#: Game.Levels.BasicGroupTheory.L09_ElementaryTwoGroup
msgid "You can use `nth_rw' to specify the location of the term to rewrite"
msgstr ""

#: Game.Levels.BasicGroupTheory.L09_ElementaryTwoGroup
msgid "Use `group' to finish the proof"
msgstr ""

#: Game.Levels.BasicGroupTheory.L10_Coset_mem
msgid "Let H be a subgroup of G.\n"
"The subset g • H := {gh | h∈H} for some g∈G is called a left coset of H.\n"
"\n"
"We first prove the simple fact that\n"
"x ∈ g • H ↔ g⁻¹ * x ∈ H\n"
"\n"
"The above lemma is called `mem_leftCoset_iff' in Mathlib."
msgstr ""

#: Game.Levels.BasicGroupTheory.L10_Coset_mem
msgid "Note that x ∈ g • H means ∃ h: G,  h ∈ H ∧  g * h = x. Use `obtain' to obtain the anxiety element h.\n"
"For example, one can use\n"
"`obtain ⟨h, hh1,hh2⟩ := h1'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L10_Coset_mem
msgid "Use `simp' to clear up «{hh2}»"
msgstr ""

#: Game.Levels.BasicGroupTheory.L10_Coset_mem
msgid "Rewrite using «{hh2}»"
msgstr ""

#: Game.Levels.BasicGroupTheory.L10_Coset_mem
msgid "The goal can be cleared by `simp'/`group' and `assumption'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L10_Coset_mem
msgid "Intro the assumption."
msgstr ""

#: Game.Levels.BasicGroupTheory.L10_Coset_mem
msgid "Use `g⁻¹ * x'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L10_Coset_mem
msgid "The goal can be cleared by `simp'/`group' and `assumption'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "Let H be a subgroup of G.\n"
"The subset g • H := {gh | h∈H} for some g∈G is called a left coset of H.\n"
"\n"
"Basically all cosets are essentially the same in the sense that there is a natural bijection between g H and k H for arbitrary g k ∈ G.\n"
"\n"
"In Lean, a bijection between two types α and β is represented by the type `Equiv α β'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "Use `constructor' to expend the definition of Equiv"
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "Pick the 3rd goal, which required to define a map from g • H to k • H using `pick_goal 3'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "Define the map g • H ∋ x ↦ (k * g⁻¹)*x. On can achive this by using `use fun x => ⟨(k * g⁻¹)*x, ?_⟩'\n"
"Here we need to prove that the function is well defined, i.e.  `(k * g⁻¹)*x ∈ k • H'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "x ∈ g • H means ∃ h ∈ H, g • h = x"
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "One can clear up the expression in «{hh}» by `simp at «{hh}»'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "To show k * g⁻¹ * ↑x ∈ k • H, one should provide an element a in h such that k g⁻¹ x  = k a. Ore one can try to replace x by g*h first and simplify the expression using `group'."
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "Now `use h'."
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "Now construct the inverse function by  `pick_goal 3'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "This is the same as the first case. We let you to practice by yourself."
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "Now `use h'."
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "`Function.LeftInverse g f' means ∀ x, g (f x) = x. So we use `intro' to reveal the goal."
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "Since `x' is a subtype, `y = x' if and only if the `y.1 = x.1'. Use `ext' to reduced the problem to comparing the values hold in  y and x."
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "Use `simp' to clear up the goal"
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "Use `group' to finish the proof."
msgstr ""

#: Game.Levels.BasicGroupTheory.L11_Coset_def
msgid "This is similar to the pervious case."
msgstr ""

#: Game.Levels.BasicGroupTheory.L12_Coset_eq
msgid "Let H be a subgroup of G.\n"
"Then g • H = k • H if and only if k⁻¹ * g ∈ H.\n"
"\n"
"We now prove only if part of this statement first."
msgstr ""

#: Game.Levels.BasicGroupTheory.L12_Coset_eq
msgid "Note that g ∈ g • H."
msgstr ""

#: Game.Levels.BasicGroupTheory.L12_Coset_eq
msgid "Use 1"
msgstr ""

#: Game.Levels.BasicGroupTheory.L12_Coset_eq
msgid "By definition 1 is certainly in H, but you still need to explicitly point it out using `Subgroup.one_mem'"
msgstr ""

#: Game.Levels.BasicGroupTheory.L12_Coset_eq
msgid "Now use «{h1}» by rewrite the right hand side of «{hg}» (rw [«{h1}»] at «{hg}»)"
msgstr ""

#: Game.Levels.BasicGroupTheory.L12_Coset_eq
msgid "Apply `mem_leftCoset_iff' and the rest is trivial."
msgstr ""

#: Game.Levels.BasicGroupTheory
msgid "Basic Group Theory"
msgstr ""

#: Game.Levels.BasicGroupTheory
msgid "We now learn some basic Group Theory."
msgstr ""

#: Game
msgid "Abstract Algebra Game"
msgstr ""

#: Game
msgid "Welcome to the abstract algebra game!"
msgstr ""

#: Game
msgid "We plan to cover basic group theory, ring theory and Galois theory."
msgstr ""

#: Game
msgid "Abstract Algebra Game"
msgstr ""

#: Game
msgid "Abstract Algebra Game for MAT205 Xiamen University Malaysia."
msgstr ""
